# Our experiments

Our design is highly inspired by the [Iden3 Protocol](https://docs.iden3.io/). Yet for the protocol to fit well with Noir, as well as to improve the performance, we make some major changes:
- Use Indexed Merkle Tree instead of Sparse Merkle Tree for non-membership verification: implementing Sparse Merkle Tree in Noir can be convoluted and unnecessarily consume an additional amount of constraints, while Indexed Merkle Tree is simpler, efficient, and can suffice our need. 
- The functions of trees, the data structure for holders in the protocol are also adjusted to archieve lower number of constraints without trading for security. For example, we use a separated shallow tree to accumulate keys for users rather than merging it with a tree of Verifiable Credential, knowing that users won't use so many keys in real life, due to the difficulty in management.

To guarantee self-sovereignty for the end users, the storing of the confidential data, and the generation of some ZK-Proofs must be operated at their local devices, leading to the trade-off in the user experience. Therefore, our design is oriented to reduce this adverse effect on the end users while not compromising their security and privacy.


# Claim

## Definition

Claim is the representation of verifiable credential in our protocol. It's granted by an issuer for a specific holder, stating some facts about this holder. For example, a claim can store age, gender, and credit score of a holder.

## Properties
No matter what entities or credential data the claims represent, they share the following properties in common:

- Claims can be updated. They have a field called “version number" which will increase 1 unit each time they're changed.
- Claims can be revoked by the Issuer, a revoked claim should be rejected by the verifier.
- Claims can be expired. If it's expirable, the expiration timestamp will be specified in its content by the Issuer, otherwise, this field should be set to 0.
- Every operation that changes the content of a claim must be executed by its Issuer.
- The holder of a claim is specified in its content.
- Zero-knowledge proofs can be generated by and only by the holder of the claim on its content.
- Claims can be verified by the Verifier. A ZK proof of a claim can only be accepted when:
    + The proof itself is verified successfully.
    - The proof carries some qualities of the claim required by the Verifier.
    - The claim is issued by a specified Issuer that the Verifier trusts.
    - The claim hasn't expired.
    - The claim is in its latest version.
    - The claim hasn't been revoked.

## Structure

The data structure for claim is an array of 8 numbers belonging to a Noir Field, and each number is called a slot. Due to the fact that common Noir Field is 254-bit, to avoid overflowing, each slot has the capacity of 253 bits, with the content for each slot being:
  + Slot 0: holderID
  + Slot 1: 
    + 128 bits: claim schema hash
    + 64 bits: expiration timestamp
    + 60 bits: version number
  + Slot 2 → 7: credential data

Slot 0 contains the holder Id which indicates the holder of the claim. The 64-bit expiration timestamp in. Slot 1 shows the time when the claim will expire, and 60-bit verision number in the same slot, quite seft-explanatory, is the current version of the claim.

**Claim schema**: the document that describes where credential data can be stored in a claim ( For example, age is stored in “Slot 2", gender is stored in “Slot 6" ). Every claim that follows a certain claim schema must store the hash of this schema in the first 128 bits of its “Slot 1”. The document can be formed in JSON or JSONLD. Here is an example of it:
```json=
{
  "@name": "International Identity Docment",
  "@type": "schema",
  "@id": "1221-3223-1111-abcd",
  "@hash": "20890844432854397172807635755323761",
  "@context": [
    "https://raw.githubusercontent.com/noir-vc/schema-models/main/json/contexts/us-document-id.json",
    "https://raw.githubusercontent.com/noir-vc/schema-models/main/json/contexts/country-code-iso-3166.json"
  ],
  "document-type": {
    "@id": "std-pos:slot-6",
    "@type": "usdi:doc-type"
  },
  "document-id": {
    "@id": "std-pos:slot-2",
    "@type": "std:str"
  },
  "full-name": {
    "@id": "std-pos:slot-3",
    "@type": "std:str"
  },
  "date-of-birth": {
    "@id": "std-pos:slot-4",
    "@type": "std:date"
  },
  "nationality": {
    "@id": "std-pos:slot-5",
    "@type": "cc3166:numeric-code"
  },
  "country-of-residence": {
    "@id": "std-pos:slot-7",
    "@type": "cc3166:numeric-code"
  },
  "@required": [
    "document-id",
    "document-type",
    "full-name",
    "date-of-birth",
    "nationality",
    "country-of-residence"
  ]
}
```
# Authorization mechanism
We use digital signatures for authorization. Particularly, when the Issuers grant, update and revoke claims for the Holders, or when the Holders generate proofs over their claims, they have to sign on their interaction as a proof of ownership.

**Signing mechanism**: We are opened to any signing algorithm that Noir can support such as EdDSA, ECDSA or even RSA. By diversifying signatures, Holders and Issuers can authorize their operations more conveniently. For example, using Passkey for passwordless authorization (requires ECDSA). The signature verification can happen either inside or outside Noir circuits without compromising the privacy of the owners because at most, they just have to expose their public keys, which pose no risk to their private keys.

**Key rotation**: Holders and Issuers can use different keys for their authorization. Once they feel insecure about a certain key, they can revoke and replace it with another one.

# Digital representation of the Holder in the protocol
Holder is associated with a set of cryptographic keys in which they can add new ones or revoke discarded ones. To represent it, we use an Increasing Merkle Tree to store the hashes of the added keys and an Indexed Merkle Tree to store the hashes of the revoked keys.

We call the hash of a public key used by the Holder “Auth":
![](https://hackmd.io/_uploads/HyUXIOZFh.png)

For public keys belonging to different types of signature, the hash function can be adjusted, but the output “Auth" will always have the same length, thanks to the characteristic of the hash function.

Each time the holder add a new key, it will be hashed into an auth, and then inserted into an **Increasing Merkle Tree** called “Auth Tree", returning a root called “Auth Root."
![](https://hackmd.io/_uploads/BJyoIuWF2.png)

Each time the holder revoke a key, its corresponding Auth will be inserted into an **Indexed Merkle Tree** called “Revoked Auth Tree", returning a root called “Revoked Auth Root."
![](https://hackmd.io/_uploads/ryOR8u-t3.png)

:::warning
**To be validly used by the Holder, a key has to satisfy: its Auth  exists in the “Auth Tree" and does not exist in the “Revoked Auth Tree."**
:::


Finally, we operate a final hash on “Auth Root" and “Revoked Auth Root" to output “Holder State". Holder State will be stored on-chain to represent the latest state of the Holder.
![](https://hackmd.io/_uploads/rysID_ZFh.png)
- The Holder Id, which is used to name the Holder, is the very first Holder State.
# Digital representation of the Issuer in the protocol
The Issuer shares the same signing mechanism as the Holder, so we use the same “Auth Tree" and “Auth Revoked Tree" for the Issuer.

An Issuer is associated with claims granted and revoked by them. Hence, they need claim-related trees in their digital representation.

Firstly, each claim, meaning an array of 8 slots, will be hashed into a value called “Claim Hash."
![](https://hackmd.io/_uploads/rkQADuZth.png)

Secondly, claim hashes are inserted into an **Increasing Merkle Tree** called “Claim Tree", returning a root called “Claim Root":
![](https://hackmd.io/_uploads/H1Ig__ZY3.png)

Then, for each claim that is revoked, its corresponding claim hash will be inserted into an **Indexed Merkle Tree** called “Revoked Claim Tree", returning a root called “Revoked Claim Root":
![](https://hackmd.io/_uploads/S1k4Od-Yn.png)

Finally, we operate a final hash on “Auth Root" ,“Revoked Auth Root", “Claim Root“ and “Revoked Claim Root” to output “Issuer State". Issuer State will be stored on-chain to represent the latest state of the Issuer.
![](https://hackmd.io/_uploads/BkRsduWK2.png)

The IssuerId, which is used to name the Holder, is the very first Issuer State.

:::warning
**To be considered valid, a Claim has to satisfy: its Hash exists in the “Claim Tree" and does not exist in the “Revoked Claim Tree."**
:::

# Digital representation of the Verifier in the protocol
Due to the fact that the Verifier doesn't have any action that needs to be authorized or impacts on any claim, they don't need to have digital representation in our protocol.

# Interactions in the protocol
## Construct a Holder

To become a Holder, an user must take 3 following steps:

- Beginning from a set of keys, we hash each of them into Auth, then add these Auths into the Auth Tree, returning the Auth Root.
- Since we haven't revoked any Auth yet, we leave the Revoked Auth Root being 0.
- Next, we hash the Auth Root and Revoked Auth Root into the very first Holder State, which is also the Holder ID.
:::warning
**Note:** We don't have to push the very first Holder State onto the blockchain. Only the later states must be.
:::
## Construct an Issuer
The initialization for an Issuer is quite similar to Holder's, with the following steps:

- Beginning from a set of keys, we hash each of them into Auth, then add these Auths into the Auth Tree, returning the Auth Root.
- Since we haven't revoked any Auth yet, we leave the Revoked Auth Root being 0
- Since we haven't issued or revoked any claim yet. The “Claim Root" and “Revoked Claim Root" will be 0.
- Next, we hash 4 roots into the very first Issuer State, which is also the Issuer ID.
:::warning
**Note:** We don't have to push the very first Issuer State onto the blockchain. Only the later states must be.
:::
## State Transition
This interaction has to be performed when every change in the trees of the Holders and Issuers happens. These changes will return in the new Holder State or Issuer State. Then the owner has to sign on the message made by the hash of their old and new state in order to authorize the change, using a valid key belonging to their old state.

Detailed steps:
  + Choose a key which is valid in the old State.
  + Create the existent proof of that key in the Auth Tree.
  + Create the non-existent proof of that key in the Revoked Auth Tree.
  + Prove that the old state is the hash of the Auth Root, Revoked Auth Root, and if the identity is an issuer, Claim Root and Revoked Claim Root.
  + Execute the change, outputting the new State.
  + Create message for signing: $Message = Hash (oldState\ \|\ newState)$
  + Sign on the message using the chosen key, returning the signature.

The owner of the identity performs these above steps in a Noir circuit, the to validate the change, the zero-knowledge proof generated is verified on-chain. If passed, the new state will be recorded.
## Update Keys
This is a concrete case of State Transition, hence, the owner performs the similar flow to the previous part. In the change executing step, the owner adds hashes of the new keys to the “Auth Tree" as well as inserts hashes of the revoked keys to the “Revoked Auth Tree" to produce a new State of their digital representation.
## Issue Claim
If the Issuer wants to issue a certain type of claim, they must first define the claim structure in a Claim Schema, specifying all the required fields and the slot for each field. To ask for issuance, the Holder has to submit their required identity information for the Issuer, in a process so-called “KYC". The submission  contains data which will be filled in the claim's slots later, along with some additional data requested by the Issuer for validation purpose. Aced the KYC process, the issuer constructs a claim following the schema and filled with content provided by the Holder. Then, the Issuer can do either of the following 2 methods to confirm their issuance with the public:

- Immediately update their trees:
    - The Issuer hashes the new Claim producing a Claim Hash, inserts this hash into their own Claim Tree. This action must be done in the State Transition circuit. 
    - The Issuer sends the State Transition zk proof to the blockchain to confirm their new State.
    - The Issuer extracts the existent proof of the Claim Hash in the Claim Tree, packs with the raw Claim, and secretly sends them back to the Holder.
    
- Queue the claim: To save gas fee, the Issuer can perform State Transition after generating a sufficient amount of claims .
    - The Issuer hashes the new Claim producing a Claim Hash, but instead of adding it to the Claim Tree, they sign on the hash to get the signature, pack it with the raw Claim, the public key which is paired with the private key used to sign the claim, existent proof of this public key, and secretly send them back to the Holder.
    - Using this signature, The Holder can still prove that they are issued the claim by the Issuer with the Verifier.
    - The Issuer will leave the newly made Claim in a queue with a certain capability, wait until the queue is full, and then perform claim addition in batch.
    - The Issuer sends the State Transition zk proof to the blockchain to confirm their new State.
    - The Issuer extracts the existent proof of each Claim Hash in the new Claim Tree, and secretly sends them back to each respective Holder.
## Update Claim

A claim update can be either single-handedly decided by the Issuer or asked by the Holder. Agreeing upon some changes in the claim with the Holder, Issuer updates some information inside the claim, at the same time increases the version number of it 1 unit. After that, the hash of the new Claim will be inserted into the “Claim Tree”, while the hash of the old one is inserted into the “Revoked Claim Tree" of the Issuer. This action must be done in the **State Transition** circuits. The Issuer then sends the **State Transition** zk proof to the blockchain to confirm their new State. Lastly, the Issuer extracts the existent proof of the new Claim Hash in the Claim Tree, packs with the new raw Claim, and secretly sends them back to the Holder.
## Revoke Claim
The revocation of a claim can be single-handedly decided by the Issuer or asked by the Holder, but it must be done by the Issuer, by taking two steps:

- Insert the hash of the Claim into their “Revoked Claim Tree". This action must be done in the State Transition circuits. 
- The Issuer sends the generated State Transition zk proof to the blockchain to confirm their new State.

From this point on, the Holder couldn't use the claim for attestation any more
# Claim Presentation
## Query a Claim
The query process involves taking either one or two pieces of credential data in the claim and asking some questions about the queried data. The query is executed inside the circuit to hide the real data in the claim. Here are the detailed steps for this process:

For querying a single field in the claim:
  + The verifier specifies the slot containing this field.
  + The verifier specifies the Operator which is one of the following functions:
    - `Equal (x)`: the field must be equal to x, this operation shouldn't be used because it reveals the real value of the field.
    - `Not equal (x)`: the field must not be equal to x
    - `Greater than (x)`: the field must be greater than x
    - `Less than (x)`: the field must be less than x
    - `In` (set): the field must be included in a specific set.
    - `Not in` (set): the field must be excluded to a specific set.
    - `In range (x, y)`: the must be greater than or equal to x, and less than or equal to y.
  + Since the query must be executed in the circuit context, and the parameters (x, y or set ) passed in to each operation are public input of the circuits, plus the fact that the **In** and **Not In** sometimes relate to a set of hundred values, the number of public inputs of the Query circuit can be significant, which makes the verifying process more expensive. To get around, we use **Merkle Tree** for **In** operation and **Indexed Merkle Tree** for **Not In** operation where we can pack every element in the set into a root and only public this root. 
  
For querying 2 different fields in the same claim:
  + The verifier specifies the corresponding slot of each field.
  + The verifier specifies the Operator which is one of the following values:
    + Equal: the first field must be equal to the second field.
    + Not equal: the first field must be different from the second field.
    + Greater than: the first field must be greater than the second field.
    + Less than: the first field must be less than the second field.
## Presenting Process
Presenting process, or Attestation, is when the Holder of a claim provide their credential information to a Verifier through the claim query process, as well as prove that the claim is still valid to obtain access to the Verifier's services, with the detailed steps:

Firstly, the Verifier send a requirement including: 
  + The Schema Hash which indicates the schema that the proven claim has to comply.
  + The IssuerId which indicates the Issuer of the proven Claim. 
  + The query for the claim. 
  + An one-off message for authorization.
  
Upon receiving the requirement, the Holder of the Claim processes the following steps:
  + Prove the Claim satisfies the Query.
  + Prove the Schema Hash of the claim matches with the one in the requirement.
  + Prove the Claim is issued by the indicated Issuer by either the existent proof of the Claim Hash in the “Claim Tree" of the Issuer or the Issuer's signature on the Claim Hash.
  + Prove the Claim hasn't been revoked in the latest State of the Issuer by the non-existent proof of the Claim Hash in the latest version of the Issuer's “Revoked Claim Tree".
  + In case when the Holder uses the Issuer's signature, they have to provide the existent and non-revoked proofs of the relative Issuer's Auth.
  + Chose a key and sign on the one-off message provided by the Verifier as a proof of ownership
  + Generate a zero-knowledge proof guaranteeing all above steps, then send it to the Verifier.

Finally, the Verifier checks the zero-knowledge proof and accepts or rejects based on the result.

# Anonymous Presentation
The Holder can enable anonymization when presenting their claim for the Verifier to unlink their HolderID with the claim being proven. To do that, we design the **Holder State Merkle Tree**, which is a normal **Merkle Tree** with each leaf being the hash of the **HolderId** and the latest **Holder State** of a certain Holder. This tree is opened for everyone to access and we store the root of it on-chain to record its latest state. 

![](https://hackmd.io/_uploads/Sy20aj-F2.png)

Each time performing **State Transition** to update keys, the Holder additionally proves their old state exists in the **Holder State Merkle Tree**, constructs a new leaf by hashing their HolderID with their new state, substitues this new leaf for the old one in the Holder State Tree, and finally, record the new tree root on-chain.

When presenting the claim, instead of exposing the HolderId for the Verifier,  the Holder can provide the existent proof of their HolderId and the latest state in the Holder State Merkle Tree. By anonymizing the Presenting process, the privacy of the Holder can be enhanced because without it, after times presenting different characteristics of their claim to access different services, their information can be resembled and exposed more.
